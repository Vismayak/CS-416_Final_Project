<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overview of Renewable Energy Adoption</title>
    <script src="https://d3js.org/d3.v7.min.js"></script> 
    <script src="https://rawgit.com/susielu/d3-annotation/master/d3-annotation.min.js"></script>
    <style>
        .chart {
            display: none;
        }
        .chart.active {
            display: block;
        }
    </style>
</head>
<body onload="init()">

    <!-- Part of the page that is static and html driven, add text stuff here -->
    <h1> Overview of Renewable Energy Adoption</h1>
    <p><strong>Data Source</strong>  - <a href="https://ourworldindata.org/renewable-energy" target="_blank">Our World in Data</a></p>
    <button id="prevButton" onclick="prevScene()">Previous</button>
    <button id="nextButton" onclick="nextScene()">Next</button>
    <div class="chart active">
        <p> The chart shows the percentage of total electricity worldwide generated from renewable sources. There is a steep increase in recent decades, thanks to worldwide cooperation towards a greener future. </p>
        <svg id="graph1"  width="800" height="400"></svg>
    </div>
    <div class="chart">
        <p> The chart shows the percentage of total electricity generated from different renewable sources over time. </p>
        <svg id="graph2"  width="800" height="400"></svg>
    </div>
    <div class="chart">
        <p>The chart represents the carbon intensity of electricity generation. Carbon intensity refers to the greenhouse gases emitted per unit of generated electricity, measured in CO<sub>2</sub> equivalents per kilowatt-hour.</p>
        <svg id="graph3"  width="800" height="400"></svg>   
        <svg id="graph4"  width="800" height="400"></svg> 
    </div>
    <div class="chart">
        <!-- User interactive scene -->
         <h3>Choose a country</h3>
        <select id="countrySelector" onchange="updateCountryCharts()">
            <option value="World">World</option>
            <!-- Add options dynamically via JavaScript -->  
        </select>
        <h4>Percentage of Electricity generated by renewables</h4>
        <svg id="countryGraph1" width="800" height="400"></svg>
        <h4>Percentage of Electricity generated by different renewable sources</h4>
        <svg id="countryGraph2" width="800" height="400"></svg>
        <h4>Carbon intensity of electricity generation - Greenhouse gases emitted per unit of generated electricity</h4>
        <svg id="countryGraph3" width="800" height="400"></svg>      
    </div>

    <!-- For charts where we might want a tool tip -->
    <div id="tooltip" style="position: absolute; opacity: 0; background: lightsteelblue; padding: 5px; border-radius: 5px;"></div>

    <!-- D3 scropting stuff will be here -->
    <script>
        let currentScene = 0;
        const sourcesJson = {
            "wind_share_elec": "Wind",
            "solar_share_elec": "Solar",
            "hydro_share_elec": "Hydro",
            "biofuel_share_elec": "Biofuel",
            "other_renewables_share_elec_exc_biofuel": "Other Renewables"
        };
        const sourcesUnit = {
            "wind_share_elec": "%",
            "solar_share_elec": "%",
            "hydro_share_elec": "%",
            "biofuel_share_elec": "%",
            "other_renewables_share_elec_exc_biofuel": "%"
        }
        const carbonImpactJson = {
            "renewables_share_elec": "% of Total Electricity from Renewables",
            "carbon_intensity_elec": "Greenhouse gases emitted per unit of generated electricity"
        };
        const carbonImpactUnit = {
            "renewables_share_elec": "%",
            "carbon_intensity_elec": "gCO2e/kWh"
        };

        let country_data;
        let world_data;

        // function to create a copy of the data
            function copyData(data) {
            return data.map(d => ({ ...d }));
        }

        function prevScene() {
            if (currentScene > 0) {
                currentScene--;
                showScene(currentScene);
            }
        }

        function nextScene() {
            if (currentScene < 3) {
                currentScene++;
                showScene(currentScene);
            }
        }

        function updateButtonVisibility() {
            const prevButton = document.getElementById("prevButton");
            const nextButton = document.getElementById("nextButton");

            if (currentScene === 0) {
                prevButton.style.display = "none";
            } else {
                prevButton.style.display = "inline";
            }

            if (currentScene === 3) {
                nextButton.style.display = "none";
            } else {
                nextButton.style.display = "inline";
            }
        }

        function showScene(sceneIndex) {
            const charts = document.querySelectorAll(".chart");
            charts.forEach((chart, index) => {
                if (index === sceneIndex) {
                    chart.classList.add("active");
                } else {
                    chart.classList.remove("active");
                }
            });
            updateButtonVisibility();
        }

        function updateDropdown(dropdownID, data, value) {
            const dropdown = document.getElementById(dropdownID);
            const values = [...new Set(data.map(d => d[value]))];
            values.forEach(value => {
                const option = document.createElement("option");
                option.value = value;
                option.text = value;
                dropdown.appendChild(option);
            });
        }

        function singleLineGraphTime(yAxisColumn, xAxisColumn, yLabel, xLabel, svg, data, yUnit, lineColor,annotationsJson) {
            // Set the dimensions and margins of the graph
            const margin = {top: 10, right: 130, bottom: 30, left: 60};
            const width = +svg.attr("width")  - margin.left - margin.right;
            const height = +svg.attr("height")  - margin.top - margin.bottom;
            const g = svg.append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            const parseTime = d3.timeParse("%Y");

            data.forEach(function(d) {
                d[xAxisColumn] = parseTime(d[xAxisColumn]);
                d[yAxisColumn] = +d[yAxisColumn];
            });

            // Add X axis
            const x = d3.scaleTime()
                .domain(d3.extent(data, function(d) { return d[xAxisColumn]; }))
                .range([0, width]);
            g.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // X axis label
            g.append("text")
                .attr("transform", "translate(" + (width/2) + " ," + (height + margin.top + 20) + ")")
                .style("text-anchor", "middle")
                .text(xLabel);

            // Add Y axis
            const y = d3.scaleLinear()
                .domain([0, d3.max(data, function(d) { return +d[yAxisColumn]; })])
                .range([height, 0]);
            g.append("g")
                .call(d3.axisLeft(y));
            
            // Y axis label
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x",0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text(yLabel);

            // Add the line
            g.append("path")
                .datum(data)
                .attr("fill", "none")
                .attr("stroke", lineColor)
                .attr("stroke-width", 1.5)
                .attr("d", d3.line()
                    .x(function(d) { return x(d[xAxisColumn]) })
                    .y(function(d) { return y(d[yAxisColumn]) })
                );
            
            // Add dots that show up on hover
            const circles = g.selectAll("circle")
                .data(data)
                .enter()
                .append("circle")
                .attr("cx", d => x(d[xAxisColumn]))
                .attr("cy", d => y(d[yAxisColumn]))
                .attr("r", 5)
                .attr("fill", lineColor)
                .style("opacity", 0);
            
            // Tooltip setup
            const tooltip = d3.select("#tooltip");

            // Use invisible rectangle to capture mouse events
            g.append("rect")
                .attr("width", width)
                .attr("height", height)
                .attr("fill", "none")
                .attr("pointer-events", "all")
                .on("mousemove", function(event) {
                    const mouse = d3.pointer(event);
                    // Get the x value of the mouse in data space
                    const mouseX = x.invert(mouse[0]);
                    // Find the data point closest to the mouse
                    const bisectDate = d3.bisector(function(d) { return d[xAxisColumn]; }).left;
                    const i = bisectDate(data, mouseX, 1);
                    const d = data[i];

                    // Show the tooltip
                    tooltip.transition()
                        .duration(100)
                        .style("opacity", .9);
                    
                    tooltip.html(`${xLabel}: `+ d3.timeFormat("%Y")(d[xAxisColumn]) + `<br/> ${yLabel}: ` + d[yAxisColumn] + yUnit)
                        .style("left", (event.pageX + 5) + "px")
                        .style("top", (event.pageY - 28) + "px");

                    // Show the circle
                    circles.style("opacity", function(d, j) {
                        return i === j ? 1 : 0;
                    });
                })
                .on("mouseout", function() {
                    tooltip.transition()
                        .duration(100)
                        .style("opacity", 0);
                    circles.style("opacity", 0);
                });
                
        // Add Annotations
        if (annotationsJson) {
            const annotations = annotationsJson.map(annotation => {
                return {
                    note: {
                        title: annotation.title,
                        label: annotation.label
                    },
                    x: x(parseTime(annotation.x)),
                    y: y(annotation.y),
                    dx: annotation.dx,
                    dy: annotation.dy
                };
            });
            g.append("g")
            .attr("class", "annotation-group")
            .call(d3.annotation()
                .annotations(annotations)
            );
        }    
        }

        function multiLineGraph(xAxisColumn, yJSON, unitJson, yLabel, xLabel, svg, data, annotationsJson) {
            // Set the dimensions and margins of the graph
            const margin = {top: 10, right: 150, bottom: 30, left: 50};
            const width = +svg.attr("width")  - margin.left - margin.right;
            const height = +svg.attr("height")  - margin.top - margin.bottom;
            const g = svg.append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            const parseTime = d3.timeParse("%Y");

            const yAxisColumns = Object.keys(yJSON);
            data.forEach(d => {
                d[xAxisColumn] = parseTime(d[xAxisColumn]);
                yAxisColumns.forEach(yCol => d[yCol] = +d[yCol]);
            });

            // Add X axis
            const x = d3.scaleTime()
                .domain(d3.extent(data, function(d) { return d[xAxisColumn]; }))
                .range([0, width]);
            g.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // Add X axis label
            // X axis label
            g.append("text")
                .attr("transform", "translate(" + (width/2) + " ," + (height + margin.top + 20) + ")")
                .style("text-anchor", "middle")
                .text(xLabel);


            // Add Y axis
            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d3.max(yAxisColumns, yCol => d[yCol]))])
                .range([height, 0]);
            g.append("g")
                .call(d3.axisLeft(y));

            // Y axis label
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x",0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text(yLabel);

            // Color palette
            const color = d3.scaleOrdinal()
                .domain(yAxisColumns)
                .range(d3.schemeCategory10);

            // Draw the lines for each y-axis column
            yAxisColumns.forEach(yCol => {
                g.append("path")
                    .datum(data)
                    .attr("fill", "none")
                    .attr("stroke", color(yCol))
                    .attr("stroke-width", 1.5)
                    .attr("d", d3.line()
                        .x(d => x(d[xAxisColumn]))
                        .y(d => y(d[yCol]))
                    );
                
                 // Add dots that show up on hover
                 g.selectAll(`circle.${yCol}`)
                    .data(data)
                    .enter()
                    .append("circle")
                    .attr("class", `dot ${yCol}`)
                    .attr("cx", d => x(d[xAxisColumn]))
                    .attr("cy", d => y(d[yCol]))
                    .attr("r", 5)
                    .attr("fill", color(yCol))
                    .style("opacity", 0);
                

            });

            // Tooltip setup
            const tooltip = d3.select("#tooltip");

            g.append("rect")
                .attr("width", width)
                .attr("height", height)
                .attr("fill", "none")
                .attr("pointer-events", "all")
                .on("mousemove", function(event) {
                    const mouse = d3.pointer(event);
                    const mouseX = x.invert(mouse[0]);
                    const bisectDate = d3.bisector(d => d[xAxisColumn]).left;
                    const i = bisectDate(data, mouseX, 1);

                    const d = data[i];

                    // Show the tooltip
                    tooltip.transition()
                        .duration(100)
                        .style("opacity", .9);

                    tooltip.html(`${xLabel}: ` + d3.timeFormat("%Y")(d[xAxisColumn]) + "<br/>"
                        + Object.keys(yJSON).map(yCol => `${yJSON[yCol]}: ${d[yCol]}${unitJson[yCol]}`).join("<br/>"))
                        .style("left", (event.pageX + 5) + "px")
                        .style("top", (event.pageY - 28) + "px");   
                    
                    // Show the circles
                    yAxisColumns.forEach(yCol => {
                        g.selectAll(`circle.dot.${yCol}`)
                            .style("opacity", function(d, j) {
                                return i === j ? 1 : 0;
                    });
                    d3.select(g.selectAll(`circle.dot.${yCol}`).nodes()[i])
                        .style("opacity", 1);
                    });
                    })
                .on("mouseout", function() {
                    tooltip.transition()
                        .duration(100)
                        .style("opacity", 0);
                   
                    yAxisColumns.forEach(yCol => {
                        g.selectAll(`circle.dot.${yCol}`)
                            .style("opacity", 0);
                    });
                });
            
            // Add legend
            const legend = g.append("g")
                .attr("transform", `translate(${width + margin.left -40}, ${margin.top})`)
                .selectAll("g")
                .data(yAxisColumns)
                .enter()
                .append("g")
                .attr("transform", (d, i) => `translate(0, ${i * 20})`);
            
            legend.append("rect")
                .attr("x", 0)
                .attr("width", 10)
                .attr("height", 10)
                .attr("fill", d => color(d));
            
            legend.append("text")
                .attr("x", 20)
                .attr("y", 10)
                .text(d => yJSON[d])
                .attr("text-anchor", "start")
                .style("alignment-baseline", "middle");
        
            // Add annotations
            if (annotationsJson) {
            const annotations = annotationsJson.map(annotation => {
                return {
                    note: {
                        title: annotation.title,
                        label: annotation.label
                    },
                    x: x(parseTime(annotation.x)),
                    y: y(annotation.y),
                    dx: annotation.dx,
                    dy: annotation.dy
                };
            });
            g.append("g")
            .attr("class", "annotation-group")
            .call(d3.annotation()
                .annotations(annotations)
            );
        }    
        }

        function filterDataByCountry(data, country) {
            return data.filter(d => d.country === country);
        }
        
        function updateCountryCharts(){
            const country = document.getElementById("countrySelector").value;
            const data = filterDataByCountry(country_data, country);

            d3.select("#countryGraph1").selectAll("*").remove();
            d3.select("#countryGraph2").selectAll("*").remove();
            d3.select("#countryGraph3").selectAll("*").remove();

            const chart1 = d3.select("#countryGraph1");
            const chart2 = d3.select("#countryGraph2");
            const chart3 = d3.select("#countryGraph3");

            singleLineGraphTime("renewables_share_elec", "year", "% of Total Electricity", "Year", chart1, copyData(data),"%", "green");
            multiLineGraph("year", sourcesJson, sourcesUnit, "% of Total Electricity", "Year", chart2, copyData(data));
            singleLineGraphTime("carbon_intensity_elec", "year", "Greenhouse gases emitted per unit of generated electricity", "Year", chart3, copyData(data).filter(d => d.carbon_intensity_elec != 0),"gCO2e/kWh", "red");
        }

        // Function to initialize the page and required data
        async function init() {
        updateButtonVisibility();
        // Load data
        world_data = await d3.csv("data/world_energy_data.csv");
        country_data = await d3.csv("data/country_energy_data.csv");

        // Add options to the dropdown
        updateDropdown("countrySelector", country_data, "country");

        const chart1 = d3.select("#graph1");
        const chart2 = d3.select("#graph2");
        const chart3 = d3.select("#graph3");
        
        const chart1Annotations = [
            {
                "x": "2016",
                "y": world_data.filter(d => d.year === "2016")[0].renewables_share_elec,
                "label": "The Paris Agreement was signed",
                "title": "2016",
                "dx": 30,
                "dy": 30
            },
            {
                "x": "2009",
                "y": world_data.filter(d => d.year === "2009")[0].renewables_share_elec,
                "label": "International Renewable Energy Agency established",
                "title": "2009",
                "dx": 30,
                "dy": 30
            }
        ];

        const chart2Annotations = [
            {
                "x":"2000",
                "y":world_data.filter(d => d.year === "2000")[0].hydro_share_elec,
                "label": "Hyrdoelectricity produces the most electricity of all renewables",
                "dx": -60,
                "dy": 30
            }
        ]

        const chart3Annotations = [
            {
                "x": "2007",
                "y": world_data.filter(d => d.year === "2007")[0].carbon_intensity_elec,
                "label": "A gradual decline in carbon intensity starting from 2007" ,
                "dx": -20,
                "dy": 50
            }
        ];

        // Scene 1: Single line graph showing renewables share of electricity and carbon intensity
        singleLineGraphTime("renewables_share_elec", "year","% of Total Electricity", "Year",chart1, copyData(world_data),"%", "green", chart1Annotations);
        // Scene 2: Multi-line graph showing different renewable sources
        multiLineGraph("year", sourcesJson, sourcesUnit,  "% of Total Electricity", "Year", chart2, copyData(world_data), chart2Annotations);
        // Scene 3: Single line graph showing carbon intensity
        singleLineGraphTime("carbon_intensity_elec", "year", "Greenhouse gases emitted per unit of generated electricity", "Year", chart3, copyData(world_data).filter(d => d.carbon_intensity_elec != 0),"gCO2e/kWh", "red", chart3Annotations);

        updateCountryCharts();
        // TODO: Add annotations to the graph
        }
    </script>
</body>
</html>
